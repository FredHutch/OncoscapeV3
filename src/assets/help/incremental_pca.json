{"method":"Incremental PCA","desc":"Incremental principal components analysis (IPCA).<br />Linear dimensionality reduction using Singular Value Decomposition of<br />centered data, keeping only the most significant singular vectors to<br />project the data to a lower dimensional space.<br />Depending on the size of the input data, this algorithm can be much more<br />memory efficient than a PCA.<br />This algorithm has constant memory complexity, on the order<br />of batch_size, enabling use of np.memmap files without loading the<br />entire file into memory.<br />The computational overhead of each SVD is<br />O(batch_size * n_features ** 2), but only 2 * batch_size samples<br />remain in memory at a time. There will be n_samples / batch_size SVD<br />computations to get the principal components, versus 1 large SVD of<br />complexity O(n_samples * n_features ** 2) for PCA.<br />Read more in the User Guide.<br />","url":"http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.IncrementalPCA.html#sklearn.decomposition.IncrementalPCA","params":[{"name":"n_components","type":"int or None, (default=None)","desc":"Number of components to keep. If n_components `` is ``None, then n_components is set to min(n_samples, n_features)."},{"name":"whiten","type":"bool, optional","desc":"When True (False by default) the components_ vectors are divided by n_samples times components_ to ensure uncorrelated outputs with unit component-wise variances. Whitening will remove some information from the transformed signal (the relative variance scales of the components) but can sometimes improve the predictive accuracy of the downstream estimators by making data respect some hard-wired assumptions."},{"name":"copy","type":"bool, (default=True)","desc":"If False, X will be overwritten. copy=False can be used to save memory but is unsafe for general use."},{"name":"batch_size","type":"int or None, (default=None)","desc":"The number of samples to use for each batch. Only used when calling fit. If batch_size is None, then batch_size is inferred from the data and set to 5 * n_features, to provide a balance between approximation accuracy and memory consumption."}],"attrs":[{"name":"components_","type":"array, shape (n_components, n_features)","desc":"Components with maximum variance."},{"name":"explained_variance_","type":"array, shape (n_components,)","desc":"Variance explained by each of the selected components."},{"name":"explained_variance_ratio_","type":"array, shape (n_components,)","desc":"Percentage of variance explained by each of the selected components. If all components are stored, the sum of explained variances is equal to 1.0."},{"name":"singular_values_","type":"array, shape (n_components,)","desc":"The singular values corresponding to each of the selected components. The singular values are equal to the 2-norms of the n_components variables in the lower-dimensional space."},{"name":"mean_","type":"array, shape (n_features,)","desc":"Per-feature empirical mean, aggregate over calls to partial_fit."},{"name":"var_","type":"array, shape (n_features,)","desc":"Per-feature empirical variance, aggregate over calls to partial_fit."},{"name":"noise_variance_","type":"float","desc":"The estimated noise covariance following the Probabilistic PCA model from Tipping and Bishop 1999. See “Pattern Recognition and Machine Learning” by C. Bishop, 12.2.1 p. 574 or http://www.miketipping.com/papers/met-mppca.pdf."},{"name":"n_components_","type":"int","desc":"The estimated number of components. Relevant when n_components=None."},{"name":"n_samples_seen_","type":"int","desc":"The number of samples processed by the estimator. Will be reset on new calls to fit, but increments across partial_fit calls."}]}