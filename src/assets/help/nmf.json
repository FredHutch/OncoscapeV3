{"method":"NMF","desc":"Non-Negative Matrix Factorization (NMF)<br />Find two non-negative matrices (W, H) whose product approximates the non-<br />negative matrix X. This factorization can be used for example for<br />dimensionality reduction, source separation or topic extraction.<br />The objective function is:<br />0.5 * ||X - WH||_Fro^2<br />+ alpha * l1_ratio * ||vec(W)||_1<br />+ alpha * l1_ratio * ||vec(H)||_1<br />+ 0.5 * alpha * (1 - l1_ratio) * ||W||_Fro^2<br />+ 0.5 * alpha * (1 - l1_ratio) * ||H||_Fro^2<br />Where:<br />||A||_Fro^2 = \\sum_{i,j} A_{ij}^2 (Frobenius norm)<br />||vec(A)||_1 = \\sum_{i,j} abs(A_{ij}) (Elementwise L1 norm)<br />For multiplicative-update (‘mu’) solver, the Frobenius norm<br />(0.5 * ||X - WH||_Fro^2) can be changed into another beta-divergence loss,<br />by changing the beta_loss parameter.<br />The objective function is minimized with an alternating minimization of W<br />and H.<br />Read more in the User Guide.<br />","url":"http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.NMF.html#sklearn.decomposition.NMF","params":[{"name":"n_components","type":"int or None","desc":"Number of components, if n_components is not set all features are kept."},{"name":"init","type":"‘random’ | ‘nndsvd’ |  ‘nndsvda’ | ‘nndsvdar’ | ‘custom’","desc":"Method used to initialize the procedure. Default: ‘nndsvd’ if n_components < n_features, otherwise random. Valid options:   ‘random’: non-negative random matrices, scaled with: sqrt(X.mean() / n_components)    ‘nndsvd’: Nonnegative Double Singular Value Decomposition (NNDSVD) initialization (better for sparseness)    ‘nndsvda’: NNDSVD with zeros filled with the average of X (better when sparsity is not desired)    ‘nndsvdar’: NNDSVD with zeros filled with small random values (generally faster, less accurate alternative to NNDSVDa for when sparsity is not desired)   ‘custom’: use custom matrices W and H"},{"name":"solver","type":"‘cd’ | ‘mu’","desc":"Numerical solver to use: ‘cd’ is a Coordinate Descent solver. ‘mu’ is a Multiplicative Update solver.  New in version 0.17: Coordinate Descent solver.   New in version 0.19: Multiplicative Update solver."},{"name":"beta_loss","type":"float or string, default ‘frobenius’","desc":"String must be in {‘frobenius’, ‘kullback-leibler’, ‘itakura-saito’}. Beta divergence to be minimized, measuring the distance between X and the dot product WH. Note that values different from ‘frobenius’ (or 2) and ‘kullback-leibler’ (or 1) lead to significantly slower fits. Note that for beta_loss <= 0 (or ‘itakura-saito’), the input matrix X cannot contain zeros. Used only in ‘mu’ solver.  New in version 0.19."},{"name":"tol","type":"float, default","desc":"Tolerance of the stopping condition."},{"name":"max_iter","type":"integer, default","desc":"Maximum number of iterations before timing out."},{"name":"random_state","type":"int, RandomState instance or None, optional, default","desc":"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."},{"name":"alpha","type":"double, default","desc":"Constant that multiplies the regularization terms. Set it to zero to have no regularization.  New in version 0.17: alpha used in the Coordinate Descent solver."},{"name":"l1_ratio","type":"double, default","desc":"The regularization mixing parameter, with 0 <= l1_ratio <= 1. For l1_ratio = 0 the penalty is an elementwise L2 penalty (aka Frobenius Norm). For l1_ratio = 1 it is an elementwise L1 penalty. For 0 < l1_ratio < 1, the penalty is a combination of L1 and L2.  New in version 0.17: Regularization parameter l1_ratio used in the Coordinate Descent solver."},{"name":"verbose","type":"bool, default=False","desc":"Whether to be verbose."},{"name":"shuffle","type":"boolean, default","desc":"If true, randomize the order of coordinates in the CD solver.  New in version 0.17: shuffle parameter used in the Coordinate Descent solver."}],"attrs":[{"name":"components_","type":"array, [n_components, n_features]","desc":"Factorization matrix, sometimes called ‘dictionary’."},{"name":"reconstruction_err_","type":"number","desc":"Frobenius norm of the matrix difference, or beta-divergence, between the training data X and the reconstructed data WH from the fitted model."},{"name":"n_iter_","type":"int","desc":"Actual number of iterations."}]}