{"method":"Spectral Coclustering","desc":"Spectral Co-Clustering algorithm (Dhillon, 2001).<br />Clusters rows and columns of an array X to solve the relaxed<br />normalized cut of the bipartite graph created from X as follows:<br />the edge between row vertex i and column vertex j has weight<br />X[i, j].<br />The resulting bicluster structure is block-diagonal, since each<br />row and each column belongs to exactly one bicluster.<br />Supports sparse matrices, as long as they are nonnegative.<br />Read more in the User Guide.<br />","url":"http://scikit-learn.org/stable/modules/generated/sklearn.cluster.bicluster.SpectralCoclustering.html#sklearn.cluster.bicluster.SpectralCoclustering","params":[{"name":"n_clusters","type":"integer, optional, default","desc":"The number of biclusters to find."},{"name":"svd_method","type":"string, optional, default","desc":"Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, use sklearn.utils.extmath.randomized_svd, which may be faster for large matrices. If ‘arpack’, use scipy.sparse.linalg.svds, which is more accurate, but possibly slower in some cases."},{"name":"n_svd_vecs","type":"int, optional, default","desc":"Number of vectors to use in calculating the SVD. Corresponds to ncv when svd_method=arpack and n_oversamples when svd_method is ‘randomized`."},{"name":"mini_batch","type":"bool, optional, default","desc":"Whether to use mini-batch k-means, which is faster but may get different results."},{"name":"init","type":"{‘k-means++’, ‘random’ or an ndarray}","desc":"Method for initialization of k-means algorithm; defaults to ‘k-means++’."},{"name":"n_init","type":"int, optional, default","desc":"Number of random initializations that are tried with the k-means algorithm. If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen."},{"name":"n_jobs","type":"int, optional, default","desc":"The number of jobs to use for the computation. This works by breaking down the pairwise matrix into n_jobs even slices and computing them in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used."},{"name":"random_state","type":"int, RandomState instance or None, optional, default","desc":"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."}],"attrs":[{"name":"rows_","type":"array-like, shape (n_row_clusters, n_rows)","desc":"Results of the clustering. rows[i, r] is True if cluster i contains row r. Available only after calling fit."},{"name":"columns_","type":"array-like, shape (n_column_clusters, n_columns)","desc":"Results of the clustering, like rows."},{"name":"row_labels_","type":"array-like, shape (n_rows,)","desc":"The bicluster label of each row."},{"name":"column_labels_","type":"array-like, shape (n_cols,)","desc":"The bicluster label of each column."}]}