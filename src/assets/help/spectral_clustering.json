{"method":"Spectral Clustering","desc":"Apply clustering to a projection to the normalized laplacian.<br />In practice Spectral Clustering is very useful when the structure of<br />the individual clusters is highly non-convex or more generally when<br />a measure of the center and spread of the cluster is not a suitable<br />description of the complete cluster. For instance when clusters are<br />nested circles on the 2D plan.<br />If affinity is the adjacency matrix of a graph, this method can be<br />used to find normalized graph cuts.<br />When calling fit, an affinity matrix is constructed using either<br />kernel function such the Gaussian (aka RBF) kernel of the euclidean<br />distanced d(X, X):<br />np.exp(-gamma * d(X,X) ** 2)<br />or a k-nearest neighbors connectivity matrix.<br />Alternatively, using precomputed, a user-provided affinity<br />matrix can be used.<br />Read more in the User Guide.<br />","url":"http://scikit-learn.org/stable/modules/generated/sklearn.cluster.SpectralClustering.html#sklearn.cluster.SpectralClustering","params":[{"name":"n_clusters","type":"integer, optional","desc":"The dimension of the projection subspace."},{"name":"eigen_solver","type":"{None, ‘arpack’, ‘lobpcg’, or ‘amg’}","desc":"The eigenvalue decomposition strategy to use. AMG requires pyamg to be installed. It can be faster on very large, sparse problems, but may also lead to instabilities"},{"name":"random_state","type":"int, RandomState instance or None, optional, default","desc":"A pseudo random number generator used for the initialization of the lobpcg eigen vectors decomposition when eigen_solver == ‘amg’ and by the K-Means initialization.  If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."},{"name":"n_init","type":"int, optional, default","desc":"Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n_init consecutive runs in terms of inertia."},{"name":"gamma","type":"float, default=1.0","desc":"Kernel coefficient for rbf, poly, sigmoid, laplacian and chi2 kernels. Ignored for affinity='nearest_neighbors'."},{"name":"affinity","type":"string, array-like or callable, default ‘rbf’","desc":"If a string, this may be one of ‘nearest_neighbors’, ‘precomputed’, ‘rbf’ or one of the kernels supported by sklearn.metrics.pairwise_kernels. Only kernels that produce similarity scores (non-negative values that increase with similarity) should be used. This property is not checked by the clustering algorithm."},{"name":"n_neighbors","type":"integer","desc":"Number of neighbors to use when constructing the affinity matrix using the nearest neighbors method. Ignored for affinity='rbf'."},{"name":"eigen_tol","type":"float, optional, default","desc":"Stopping criterion for eigendecomposition of the Laplacian matrix when using arpack eigen_solver."},{"name":"assign_labels","type":"{‘kmeans’, ‘discretize’}, default","desc":"The strategy to use to assign labels in the embedding space. There are two ways to assign labels after the laplacian embedding. k-means can be applied and is a popular choice. But it can also be sensitive to initialization. Discretization is another approach which is less sensitive to random initialization."},{"name":"degree","type":"float, default=3","desc":"Degree of the polynomial kernel. Ignored by other kernels."},{"name":"coef0","type":"float, default=1","desc":"Zero coefficient for polynomial and sigmoid kernels. Ignored by other kernels."},{"name":"kernel_params","type":"dictionary of string to any, optional","desc":"Parameters (keyword arguments) and values for kernel passed as callable object. Ignored by other kernels."},{"name":"n_jobs","type":"int, optional (default = 1)","desc":"The number of parallel jobs to run. If -1, then the number of jobs is set to the number of CPU cores."}],"attrs":[{"name":"affinity_matrix_","type":"array-like, shape (n_samples, n_samples)","desc":"Affinity matrix used for clustering. Available only if after calling fit."},{"name":"labels_","type":"","desc":"Labels of each point"}]}