{"method":"Fastica","desc":"Perform Fast Independent Component Analysis.<br />Read more in the User Guide.<br />","url":"http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.fastica.html","params":[{"name":"X","type":"array-like, shape (n_samples, n_features)","desc":"Training vector, where n_samples is the number of samples and n_features is the number of features."},{"name":"n_components","type":"int, optional","desc":"Number of components to extract. If None no dimension reduction is performed."},{"name":"algorithm","type":"{‘parallel’, ‘deflation’}, optional","desc":"Apply a parallel or deflational FASTICA algorithm."},{"name":"whiten","type":"boolean, optional","desc":"If True perform an initial whitening of the data. If False, the data is assumed to have already been preprocessed: it should be centered, normed and white. Otherwise you will get incorrect results. In this case the parameter n_components will be ignored."},{"name":"fun","type":"string or function, optional. Default","desc":"The functional form of the G function used in the approximation to neg-entropy. Could be either ‘logcosh’, ‘exp’, or ‘cube’. You can also provide your own function. It should return a tuple containing the value of the function, and of its derivative, in the point. Example:  def my_g(x): return x ** 3, 3 * x ** 2"},{"name":"fun_args","type":"dictionary, optional","desc":"Arguments to send to the functional form. If empty or None and if fun=’logcosh’, fun_args will take value {‘alpha’ : 1.0}"},{"name":"max_iter","type":"int, optional","desc":"Maximum number of iterations to perform."},{"name":"tol","type":"float, optional","desc":"A positive scalar giving the tolerance at which the un-mixing matrix is considered to have converged."},{"name":"w_init","type":"(n_components, n_components) array, optional","desc":"Initial un-mixing array of dimension (n.comp,n.comp). If None (default) then an array of normal r.v.’s is used."},{"name":"random_state","type":"int, RandomState instance or None, optional (default=None)","desc":"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."},{"name":"return_X_mean","type":"bool, optional","desc":"If True, X_mean is returned too."},{"name":"compute_sources","type":"bool, optional","desc":"If False, sources are not computed, but only the rotation matrix. This can save memory when working with big data. Defaults to True."},{"name":"return_n_iter","type":"bool, optional","desc":"Whether or not to return the number of iterations."}],"attrs":[{"name":"K","type":"array, shape (n_components, n_features) | None.","desc":"If whiten is ‘True’, K is the pre-whitening matrix that projects data onto the first n_components principal components. If whiten is ‘False’, K is ‘None’."},{"name":"W","type":"array, shape (n_components, n_components)","desc":"Estimated un-mixing matrix. The mixing matrix can be obtained by: w = np.dot(W, K.T) A = w.T * (w * w.T).I"},{"name":"S","type":"array, shape (n_samples, n_components) | None","desc":"Estimated source matrix"},{"name":"X_mean","type":"array, shape (n_features, )","desc":"The mean over features. Returned only if return_X_mean is True."},{"name":"n_iter","type":"int","desc":"If the algorithm is “deflation”, n_iter is the maximum number of iterations run across all components. Else they are just the number of iterations taken to converge. This is returned only when return_n_iter is set to True."}]}