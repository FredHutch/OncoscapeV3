{"method":"Sparse Coder","desc":"<span class='help-method'>Sparse coding</span>Finds a sparse representation of data against a fixed, precomputed dictionary. Each row of the result is the solution to a sparse coding problem. The goal is to find a sparse array code such that: X ~= code * dictionary Read more in the scikit-learn user guide. ","url":"http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.SparseCoder.html#sklearn.decomposition.SparseCoder","params":[{"name":"dictionary","type":"array, [n_components, n_features]","desc":"The dictionary atoms used for sparse coding. Lines are assumed to be normalized to unit norm."},{"name":"transform algorithm","type":"{‘lasso_lars’, ‘lasso_cd’, ‘lars’, ‘omp’,     ‘threshold’}","desc":"Algorithm used to transform the data: lars: uses the least angle regression method (linear_model.lars_path) lasso_lars: uses Lars to compute the Lasso solution lasso_cd: uses the coordinate descent method to compute the Lasso solution (linear_model.Lasso). lasso_lars will be faster if the estimated components are sparse. omp: uses orthogonal matching pursuit to estimate the sparse solution threshold: squashes to zero all coefficients less than alpha from the projection dictionary * X'"},{"name":"transform n nonzero coefs","type":"int, 0.1 * n_features by default","desc":"Number of nonzero coefficients to target in each column of the solution. This is only used by algorithm=’lars’ and algorithm=’omp’ and is overridden by alpha in the omp case."},{"name":"transform alpha","type":"float, 1. by default","desc":"If algorithm=’lasso_lars’ or algorithm=’lasso_cd’, alpha is the penalty applied to the L1 norm. If algorithm=’threshold’, alpha is the absolute value of the threshold below which coefficients will be squashed to zero. If algorithm=’omp’, alpha is the tolerance parameter: the value of the reconstruction error targeted. In this case, it overrides n_nonzero_coefs."},{"name":"split sign","type":"bool, False by default","desc":"Whether to split the sparse feature vector into the concatenation of its negative part and its positive part. This can improve the performance of downstream classifiers."},{"name":"n jobs","type":"int,","desc":"number of parallel jobs to run"}],"attrs":[{"name":"components","type":"array, [n_components, n_features]","desc":"The unchanged dictionary atoms"}]}