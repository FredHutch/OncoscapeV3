{"method":"Spectral Coclustering","desc":"<span class='help-method'>Spectral Co-Clustering algorithm (Dhillon, 2001).</span>Clusters rows and columns of an array X to solve the relaxed normalized cut of the bipartite graph created from X as follows: the edge between row vertex i and column vertex j has weight X[i, j]. The resulting bicluster structure is block-diagonal, since each row and each column belongs to exactly one bicluster. Supports sparse matrices, as long as they are nonnegative. Read more in the scikit-learn user guide. ","url":"http://scikit-learn.org/stable/modules/generated/sklearn.cluster.bicluster.SpectralCoclustering.html#sklearn.cluster.bicluster.SpectralCoclustering","params":[{"name":"n clusters","type":"integer, optional, default","desc":"The number of biclusters to find."},{"name":"svd method","type":"string, optional, default","desc":"Selects the algorithm for finding singular vectors. May be ‘randomized’ or ‘arpack’. If ‘randomized’, use sklearn.utils.extmath.randomized_svd, which may be faster for large matrices. If ‘arpack’, use scipy.sparse.linalg.svds, which is more accurate, but possibly slower in some cases."},{"name":"n svd vecs","type":"int, optional, default","desc":"Number of vectors to use in calculating the SVD. Corresponds to ncv when svd_method=arpack and n_oversamples when svd_method is ‘randomized`."},{"name":"mini batch","type":"bool, optional, default","desc":"Whether to use mini-batch k-means, which is faster but may get different results."},{"name":"init","type":"{‘k-means++’, ‘random’ or an ndarray}","desc":"Method for initialization of k-means algorithm; defaults to ‘k-means++’."},{"name":"n init","type":"int, optional, default","desc":"Number of random initializations that are tried with the k-means algorithm. If mini-batch k-means is used, the best initialization is chosen and the algorithm runs once. Otherwise, the algorithm is run for each initialization and the best solution chosen."},{"name":"n jobs","type":"int, optional, default","desc":"The number of jobs to use for the computation. This works by breaking down the pairwise matrix into n_jobs even slices and computing them in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used."},{"name":"random state","type":"int, RandomState instance or None, optional, default","desc":"If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random."}],"attrs":[{"name":"rows","type":"array-like, shape (n_row_clusters, n_rows)","desc":"Results of the clustering. rows[i, r] is True if cluster i contains row r. Available only after calling fit."},{"name":"columns","type":"array-like, shape (n_column_clusters, n_columns)","desc":"Results of the clustering, like rows."},{"name":"row labels","type":"array-like, shape (n_rows,)","desc":"The bicluster label of each row."},{"name":"column labels","type":"array-like, shape (n_cols,)","desc":"The bicluster label of each column."}]}